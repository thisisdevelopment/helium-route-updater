// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: service/iot_config.proto

package iot_config

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OrgClient is the client API for Org service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrgClient interface {
	// List Org (no auth)
	List(ctx context.Context, in *OrgListReqV1, opts ...grpc.CallOption) (*OrgListResV1, error)
	// Get Org (no auth)
	Get(ctx context.Context, in *OrgGetReqV1, opts ...grpc.CallOption) (*OrgResV1, error)
	// Create Org on Helium Network (auth admin only)
	CreateHelium(ctx context.Context, in *OrgCreateHeliumReqV1, opts ...grpc.CallOption) (*OrgResV1, error)
	// Create Org on any network (auth admin only)
	CreateRoamer(ctx context.Context, in *OrgCreateRoamerReqV1, opts ...grpc.CallOption) (*OrgResV1, error)
	// Update any Org (Helium or Roaming)
	// Modify payer and add/remove delegate keys (owner/admin)
	// Modify owner and add/remove devaddr constraints (auth admin only)
	Update(ctx context.Context, in *OrgUpdateReqV1, opts ...grpc.CallOption) (*OrgResV1, error)
	// Disable an org, this sends a stream route delete update to HPR
	// for all associated routes (auth admin only)
	Disable(ctx context.Context, in *OrgDisableReqV1, opts ...grpc.CallOption) (*OrgDisableResV1, error)
	// Enable an org, this sends a stream route create update to HPR
	// for all associated routes (auth admin only)
	Enable(ctx context.Context, in *OrgEnableReqV1, opts ...grpc.CallOption) (*OrgEnableResV1, error)
}

type orgClient struct {
	cc grpc.ClientConnInterface
}

func NewOrgClient(cc grpc.ClientConnInterface) OrgClient {
	return &orgClient{cc}
}

func (c *orgClient) List(ctx context.Context, in *OrgListReqV1, opts ...grpc.CallOption) (*OrgListResV1, error) {
	out := new(OrgListResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/list", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) Get(ctx context.Context, in *OrgGetReqV1, opts ...grpc.CallOption) (*OrgResV1, error) {
	out := new(OrgResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) CreateHelium(ctx context.Context, in *OrgCreateHeliumReqV1, opts ...grpc.CallOption) (*OrgResV1, error) {
	out := new(OrgResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/create_helium", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) CreateRoamer(ctx context.Context, in *OrgCreateRoamerReqV1, opts ...grpc.CallOption) (*OrgResV1, error) {
	out := new(OrgResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/create_roamer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) Update(ctx context.Context, in *OrgUpdateReqV1, opts ...grpc.CallOption) (*OrgResV1, error) {
	out := new(OrgResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) Disable(ctx context.Context, in *OrgDisableReqV1, opts ...grpc.CallOption) (*OrgDisableResV1, error) {
	out := new(OrgDisableResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/disable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgClient) Enable(ctx context.Context, in *OrgEnableReqV1, opts ...grpc.CallOption) (*OrgEnableResV1, error) {
	out := new(OrgEnableResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.org/enable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrgServer is the server API for Org service.
// All implementations must embed UnimplementedOrgServer
// for forward compatibility
type OrgServer interface {
	// List Org (no auth)
	List(context.Context, *OrgListReqV1) (*OrgListResV1, error)
	// Get Org (no auth)
	Get(context.Context, *OrgGetReqV1) (*OrgResV1, error)
	// Create Org on Helium Network (auth admin only)
	CreateHelium(context.Context, *OrgCreateHeliumReqV1) (*OrgResV1, error)
	// Create Org on any network (auth admin only)
	CreateRoamer(context.Context, *OrgCreateRoamerReqV1) (*OrgResV1, error)
	// Update any Org (Helium or Roaming)
	// Modify payer and add/remove delegate keys (owner/admin)
	// Modify owner and add/remove devaddr constraints (auth admin only)
	Update(context.Context, *OrgUpdateReqV1) (*OrgResV1, error)
	// Disable an org, this sends a stream route delete update to HPR
	// for all associated routes (auth admin only)
	Disable(context.Context, *OrgDisableReqV1) (*OrgDisableResV1, error)
	// Enable an org, this sends a stream route create update to HPR
	// for all associated routes (auth admin only)
	Enable(context.Context, *OrgEnableReqV1) (*OrgEnableResV1, error)
	mustEmbedUnimplementedOrgServer()
}

// UnimplementedOrgServer must be embedded to have forward compatible implementations.
type UnimplementedOrgServer struct {
}

func (UnimplementedOrgServer) List(context.Context, *OrgListReqV1) (*OrgListResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedOrgServer) Get(context.Context, *OrgGetReqV1) (*OrgResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedOrgServer) CreateHelium(context.Context, *OrgCreateHeliumReqV1) (*OrgResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHelium not implemented")
}
func (UnimplementedOrgServer) CreateRoamer(context.Context, *OrgCreateRoamerReqV1) (*OrgResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRoamer not implemented")
}
func (UnimplementedOrgServer) Update(context.Context, *OrgUpdateReqV1) (*OrgResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedOrgServer) Disable(context.Context, *OrgDisableReqV1) (*OrgDisableResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disable not implemented")
}
func (UnimplementedOrgServer) Enable(context.Context, *OrgEnableReqV1) (*OrgEnableResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enable not implemented")
}
func (UnimplementedOrgServer) mustEmbedUnimplementedOrgServer() {}

// UnsafeOrgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrgServer will
// result in compilation errors.
type UnsafeOrgServer interface {
	mustEmbedUnimplementedOrgServer()
}

func RegisterOrgServer(s grpc.ServiceRegistrar, srv OrgServer) {
	s.RegisterService(&Org_ServiceDesc, srv)
}

func _Org_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgListReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/list",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).List(ctx, req.(*OrgListReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgGetReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).Get(ctx, req.(*OrgGetReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_CreateHelium_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgCreateHeliumReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).CreateHelium(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/create_helium",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).CreateHelium(ctx, req.(*OrgCreateHeliumReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_CreateRoamer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgCreateRoamerReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).CreateRoamer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/create_roamer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).CreateRoamer(ctx, req.(*OrgCreateRoamerReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgUpdateReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).Update(ctx, req.(*OrgUpdateReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_Disable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgDisableReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).Disable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/disable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).Disable(ctx, req.(*OrgDisableReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Org_Enable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrgEnableReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrgServer).Enable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.org/enable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrgServer).Enable(ctx, req.(*OrgEnableReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

// Org_ServiceDesc is the grpc.ServiceDesc for Org service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Org_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "helium.iot_config.org",
	HandlerType: (*OrgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _Org_List_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Org_Get_Handler,
		},
		{
			MethodName: "create_helium",
			Handler:    _Org_CreateHelium_Handler,
		},
		{
			MethodName: "create_roamer",
			Handler:    _Org_CreateRoamer_Handler,
		},
		{
			MethodName: "update",
			Handler:    _Org_Update_Handler,
		},
		{
			MethodName: "disable",
			Handler:    _Org_Disable_Handler,
		},
		{
			MethodName: "enable",
			Handler:    _Org_Enable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/iot_config.proto",
}

// RouteClient is the client API for Route service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RouteClient interface {
	// List Routes for an Org (auth delegate_keys/owner/admin)
	List(ctx context.Context, in *RouteListReqV1, opts ...grpc.CallOption) (*RouteListResV1, error)
	// Get Route for an Org (auth delegate_keys/owner/admin)
	Get(ctx context.Context, in *RouteGetReqV1, opts ...grpc.CallOption) (*RouteResV1, error)
	// Create Route for an Org (auth delegate_keys/owner/admin)
	Create(ctx context.Context, in *RouteCreateReqV1, opts ...grpc.CallOption) (*RouteResV1, error)
	// Update Route for an Org (auth delegate_keys/owner/admin)
	Update(ctx context.Context, in *RouteUpdateReqV1, opts ...grpc.CallOption) (*RouteResV1, error)
	// Delete Route for an Org (auth delegate_keys/owner/admin)
	Delete(ctx context.Context, in *RouteDeleteReqV1, opts ...grpc.CallOption) (*RouteResV1, error)
	// Stream Routes update (auth admin only)
	Stream(ctx context.Context, in *RouteStreamReqV1, opts ...grpc.CallOption) (Route_StreamClient, error)
	// Get EUIs for a Route (auth delegate_keys/owner/admin)
	GetEuis(ctx context.Context, in *RouteGetEuisReqV1, opts ...grpc.CallOption) (Route_GetEuisClient, error)
	// Update (single add or remove) EUIs for a Route (auth
	// delegate_keys/owner/admin)
	UpdateEuis(ctx context.Context, opts ...grpc.CallOption) (Route_UpdateEuisClient, error)
	// Get DevAddr Ranges for a Route (auth delegate_keys/owner/admin)
	GetDevaddrRanges(ctx context.Context, in *RouteGetDevaddrRangesReqV1, opts ...grpc.CallOption) (Route_GetDevaddrRangesClient, error)
	// Update (single add or remove) DevAddr Ranges for a Route (auth
	// delegate_keys/owner/admin)
	UpdateDevaddrRanges(ctx context.Context, opts ...grpc.CallOption) (Route_UpdateDevaddrRangesClient, error)
	// List Filters for a Route (auth delegate_keys/owner/admin)
	ListSkfs(ctx context.Context, in *RouteSkfListReqV1, opts ...grpc.CallOption) (Route_ListSkfsClient, error)
	// List Filters for a DevAddr (auth delegate_keys/owner/admin
	GetSkfs(ctx context.Context, in *RouteSkfGetReqV1, opts ...grpc.CallOption) (Route_GetSkfsClient, error)
	// Update Filters for an Org (auth delegate_keys/owner/admin)
	UpdateSkfs(ctx context.Context, in *RouteSkfUpdateReqV1, opts ...grpc.CallOption) (*RouteSkfUpdateResV1, error)
}

type routeClient struct {
	cc grpc.ClientConnInterface
}

func NewRouteClient(cc grpc.ClientConnInterface) RouteClient {
	return &routeClient{cc}
}

func (c *routeClient) List(ctx context.Context, in *RouteListReqV1, opts ...grpc.CallOption) (*RouteListResV1, error) {
	out := new(RouteListResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/list", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Get(ctx context.Context, in *RouteGetReqV1, opts ...grpc.CallOption) (*RouteResV1, error) {
	out := new(RouteResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Create(ctx context.Context, in *RouteCreateReqV1, opts ...grpc.CallOption) (*RouteResV1, error) {
	out := new(RouteResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Update(ctx context.Context, in *RouteUpdateReqV1, opts ...grpc.CallOption) (*RouteResV1, error) {
	out := new(RouteResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Delete(ctx context.Context, in *RouteDeleteReqV1, opts ...grpc.CallOption) (*RouteResV1, error) {
	out := new(RouteResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Stream(ctx context.Context, in *RouteStreamReqV1, opts ...grpc.CallOption) (Route_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[0], "/helium.iot_config.route/stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_StreamClient interface {
	Recv() (*RouteStreamResV1, error)
	grpc.ClientStream
}

type routeStreamClient struct {
	grpc.ClientStream
}

func (x *routeStreamClient) Recv() (*RouteStreamResV1, error) {
	m := new(RouteStreamResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) GetEuis(ctx context.Context, in *RouteGetEuisReqV1, opts ...grpc.CallOption) (Route_GetEuisClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[1], "/helium.iot_config.route/get_euis", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeGetEuisClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_GetEuisClient interface {
	Recv() (*EuiPairV1, error)
	grpc.ClientStream
}

type routeGetEuisClient struct {
	grpc.ClientStream
}

func (x *routeGetEuisClient) Recv() (*EuiPairV1, error) {
	m := new(EuiPairV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) UpdateEuis(ctx context.Context, opts ...grpc.CallOption) (Route_UpdateEuisClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[2], "/helium.iot_config.route/update_euis", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeUpdateEuisClient{stream}
	return x, nil
}

type Route_UpdateEuisClient interface {
	Send(*RouteUpdateEuisReqV1) error
	CloseAndRecv() (*RouteEuisResV1, error)
	grpc.ClientStream
}

type routeUpdateEuisClient struct {
	grpc.ClientStream
}

func (x *routeUpdateEuisClient) Send(m *RouteUpdateEuisReqV1) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routeUpdateEuisClient) CloseAndRecv() (*RouteEuisResV1, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RouteEuisResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) GetDevaddrRanges(ctx context.Context, in *RouteGetDevaddrRangesReqV1, opts ...grpc.CallOption) (Route_GetDevaddrRangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[3], "/helium.iot_config.route/get_devaddr_ranges", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeGetDevaddrRangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_GetDevaddrRangesClient interface {
	Recv() (*DevaddrRangeV1, error)
	grpc.ClientStream
}

type routeGetDevaddrRangesClient struct {
	grpc.ClientStream
}

func (x *routeGetDevaddrRangesClient) Recv() (*DevaddrRangeV1, error) {
	m := new(DevaddrRangeV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) UpdateDevaddrRanges(ctx context.Context, opts ...grpc.CallOption) (Route_UpdateDevaddrRangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[4], "/helium.iot_config.route/update_devaddr_ranges", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeUpdateDevaddrRangesClient{stream}
	return x, nil
}

type Route_UpdateDevaddrRangesClient interface {
	Send(*RouteUpdateDevaddrRangesReqV1) error
	CloseAndRecv() (*RouteDevaddrRangesResV1, error)
	grpc.ClientStream
}

type routeUpdateDevaddrRangesClient struct {
	grpc.ClientStream
}

func (x *routeUpdateDevaddrRangesClient) Send(m *RouteUpdateDevaddrRangesReqV1) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routeUpdateDevaddrRangesClient) CloseAndRecv() (*RouteDevaddrRangesResV1, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RouteDevaddrRangesResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) ListSkfs(ctx context.Context, in *RouteSkfListReqV1, opts ...grpc.CallOption) (Route_ListSkfsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[5], "/helium.iot_config.route/list_skfs", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeListSkfsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_ListSkfsClient interface {
	Recv() (*SkfV1, error)
	grpc.ClientStream
}

type routeListSkfsClient struct {
	grpc.ClientStream
}

func (x *routeListSkfsClient) Recv() (*SkfV1, error) {
	m := new(SkfV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) GetSkfs(ctx context.Context, in *RouteSkfGetReqV1, opts ...grpc.CallOption) (Route_GetSkfsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Route_ServiceDesc.Streams[6], "/helium.iot_config.route/get_skfs", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeGetSkfsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_GetSkfsClient interface {
	Recv() (*SkfV1, error)
	grpc.ClientStream
}

type routeGetSkfsClient struct {
	grpc.ClientStream
}

func (x *routeGetSkfsClient) Recv() (*SkfV1, error) {
	m := new(SkfV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) UpdateSkfs(ctx context.Context, in *RouteSkfUpdateReqV1, opts ...grpc.CallOption) (*RouteSkfUpdateResV1, error) {
	out := new(RouteSkfUpdateResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.route/update_skfs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouteServer is the server API for Route service.
// All implementations must embed UnimplementedRouteServer
// for forward compatibility
type RouteServer interface {
	// List Routes for an Org (auth delegate_keys/owner/admin)
	List(context.Context, *RouteListReqV1) (*RouteListResV1, error)
	// Get Route for an Org (auth delegate_keys/owner/admin)
	Get(context.Context, *RouteGetReqV1) (*RouteResV1, error)
	// Create Route for an Org (auth delegate_keys/owner/admin)
	Create(context.Context, *RouteCreateReqV1) (*RouteResV1, error)
	// Update Route for an Org (auth delegate_keys/owner/admin)
	Update(context.Context, *RouteUpdateReqV1) (*RouteResV1, error)
	// Delete Route for an Org (auth delegate_keys/owner/admin)
	Delete(context.Context, *RouteDeleteReqV1) (*RouteResV1, error)
	// Stream Routes update (auth admin only)
	Stream(*RouteStreamReqV1, Route_StreamServer) error
	// Get EUIs for a Route (auth delegate_keys/owner/admin)
	GetEuis(*RouteGetEuisReqV1, Route_GetEuisServer) error
	// Update (single add or remove) EUIs for a Route (auth
	// delegate_keys/owner/admin)
	UpdateEuis(Route_UpdateEuisServer) error
	// Get DevAddr Ranges for a Route (auth delegate_keys/owner/admin)
	GetDevaddrRanges(*RouteGetDevaddrRangesReqV1, Route_GetDevaddrRangesServer) error
	// Update (single add or remove) DevAddr Ranges for a Route (auth
	// delegate_keys/owner/admin)
	UpdateDevaddrRanges(Route_UpdateDevaddrRangesServer) error
	// List Filters for a Route (auth delegate_keys/owner/admin)
	ListSkfs(*RouteSkfListReqV1, Route_ListSkfsServer) error
	// List Filters for a DevAddr (auth delegate_keys/owner/admin
	GetSkfs(*RouteSkfGetReqV1, Route_GetSkfsServer) error
	// Update Filters for an Org (auth delegate_keys/owner/admin)
	UpdateSkfs(context.Context, *RouteSkfUpdateReqV1) (*RouteSkfUpdateResV1, error)
	mustEmbedUnimplementedRouteServer()
}

// UnimplementedRouteServer must be embedded to have forward compatible implementations.
type UnimplementedRouteServer struct {
}

func (UnimplementedRouteServer) List(context.Context, *RouteListReqV1) (*RouteListResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRouteServer) Get(context.Context, *RouteGetReqV1) (*RouteResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRouteServer) Create(context.Context, *RouteCreateReqV1) (*RouteResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedRouteServer) Update(context.Context, *RouteUpdateReqV1) (*RouteResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedRouteServer) Delete(context.Context, *RouteDeleteReqV1) (*RouteResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRouteServer) Stream(*RouteStreamReqV1, Route_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}
func (UnimplementedRouteServer) GetEuis(*RouteGetEuisReqV1, Route_GetEuisServer) error {
	return status.Errorf(codes.Unimplemented, "method GetEuis not implemented")
}
func (UnimplementedRouteServer) UpdateEuis(Route_UpdateEuisServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateEuis not implemented")
}
func (UnimplementedRouteServer) GetDevaddrRanges(*RouteGetDevaddrRangesReqV1, Route_GetDevaddrRangesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDevaddrRanges not implemented")
}
func (UnimplementedRouteServer) UpdateDevaddrRanges(Route_UpdateDevaddrRangesServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateDevaddrRanges not implemented")
}
func (UnimplementedRouteServer) ListSkfs(*RouteSkfListReqV1, Route_ListSkfsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListSkfs not implemented")
}
func (UnimplementedRouteServer) GetSkfs(*RouteSkfGetReqV1, Route_GetSkfsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSkfs not implemented")
}
func (UnimplementedRouteServer) UpdateSkfs(context.Context, *RouteSkfUpdateReqV1) (*RouteSkfUpdateResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSkfs not implemented")
}
func (UnimplementedRouteServer) mustEmbedUnimplementedRouteServer() {}

// UnsafeRouteServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RouteServer will
// result in compilation errors.
type UnsafeRouteServer interface {
	mustEmbedUnimplementedRouteServer()
}

func RegisterRouteServer(s grpc.ServiceRegistrar, srv RouteServer) {
	s.RegisterService(&Route_ServiceDesc, srv)
}

func _Route_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteListReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/list",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).List(ctx, req.(*RouteListReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteGetReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Get(ctx, req.(*RouteGetReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteCreateReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Create(ctx, req.(*RouteCreateReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteUpdateReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Update(ctx, req.(*RouteUpdateReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteDeleteReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Delete(ctx, req.(*RouteDeleteReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteStreamReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).Stream(m, &routeStreamServer{stream})
}

type Route_StreamServer interface {
	Send(*RouteStreamResV1) error
	grpc.ServerStream
}

type routeStreamServer struct {
	grpc.ServerStream
}

func (x *routeStreamServer) Send(m *RouteStreamResV1) error {
	return x.ServerStream.SendMsg(m)
}

func _Route_GetEuis_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteGetEuisReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).GetEuis(m, &routeGetEuisServer{stream})
}

type Route_GetEuisServer interface {
	Send(*EuiPairV1) error
	grpc.ServerStream
}

type routeGetEuisServer struct {
	grpc.ServerStream
}

func (x *routeGetEuisServer) Send(m *EuiPairV1) error {
	return x.ServerStream.SendMsg(m)
}

func _Route_UpdateEuis_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouteServer).UpdateEuis(&routeUpdateEuisServer{stream})
}

type Route_UpdateEuisServer interface {
	SendAndClose(*RouteEuisResV1) error
	Recv() (*RouteUpdateEuisReqV1, error)
	grpc.ServerStream
}

type routeUpdateEuisServer struct {
	grpc.ServerStream
}

func (x *routeUpdateEuisServer) SendAndClose(m *RouteEuisResV1) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routeUpdateEuisServer) Recv() (*RouteUpdateEuisReqV1, error) {
	m := new(RouteUpdateEuisReqV1)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Route_GetDevaddrRanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteGetDevaddrRangesReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).GetDevaddrRanges(m, &routeGetDevaddrRangesServer{stream})
}

type Route_GetDevaddrRangesServer interface {
	Send(*DevaddrRangeV1) error
	grpc.ServerStream
}

type routeGetDevaddrRangesServer struct {
	grpc.ServerStream
}

func (x *routeGetDevaddrRangesServer) Send(m *DevaddrRangeV1) error {
	return x.ServerStream.SendMsg(m)
}

func _Route_UpdateDevaddrRanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouteServer).UpdateDevaddrRanges(&routeUpdateDevaddrRangesServer{stream})
}

type Route_UpdateDevaddrRangesServer interface {
	SendAndClose(*RouteDevaddrRangesResV1) error
	Recv() (*RouteUpdateDevaddrRangesReqV1, error)
	grpc.ServerStream
}

type routeUpdateDevaddrRangesServer struct {
	grpc.ServerStream
}

func (x *routeUpdateDevaddrRangesServer) SendAndClose(m *RouteDevaddrRangesResV1) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routeUpdateDevaddrRangesServer) Recv() (*RouteUpdateDevaddrRangesReqV1, error) {
	m := new(RouteUpdateDevaddrRangesReqV1)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Route_ListSkfs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteSkfListReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).ListSkfs(m, &routeListSkfsServer{stream})
}

type Route_ListSkfsServer interface {
	Send(*SkfV1) error
	grpc.ServerStream
}

type routeListSkfsServer struct {
	grpc.ServerStream
}

func (x *routeListSkfsServer) Send(m *SkfV1) error {
	return x.ServerStream.SendMsg(m)
}

func _Route_GetSkfs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteSkfGetReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).GetSkfs(m, &routeGetSkfsServer{stream})
}

type Route_GetSkfsServer interface {
	Send(*SkfV1) error
	grpc.ServerStream
}

type routeGetSkfsServer struct {
	grpc.ServerStream
}

func (x *routeGetSkfsServer) Send(m *SkfV1) error {
	return x.ServerStream.SendMsg(m)
}

func _Route_UpdateSkfs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteSkfUpdateReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).UpdateSkfs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.route/update_skfs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).UpdateSkfs(ctx, req.(*RouteSkfUpdateReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

// Route_ServiceDesc is the grpc.ServiceDesc for Route service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Route_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "helium.iot_config.route",
	HandlerType: (*RouteServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _Route_List_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Route_Get_Handler,
		},
		{
			MethodName: "create",
			Handler:    _Route_Create_Handler,
		},
		{
			MethodName: "update",
			Handler:    _Route_Update_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _Route_Delete_Handler,
		},
		{
			MethodName: "update_skfs",
			Handler:    _Route_UpdateSkfs_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "stream",
			Handler:       _Route_Stream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "get_euis",
			Handler:       _Route_GetEuis_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "update_euis",
			Handler:       _Route_UpdateEuis_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "get_devaddr_ranges",
			Handler:       _Route_GetDevaddrRanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "update_devaddr_ranges",
			Handler:       _Route_UpdateDevaddrRanges_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "list_skfs",
			Handler:       _Route_ListSkfs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "get_skfs",
			Handler:       _Route_GetSkfs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service/iot_config.proto",
}

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayClient interface {
	// Return the region params for the asserted location of the signed gateway
	// address (no auth, but signature validated)
	RegionParams(ctx context.Context, in *GatewayRegionParamsReqV1, opts ...grpc.CallOption) (*GatewayRegionParamsResV1, error)
	// Get H3 Location for a gateway (auth admin only)
	Location(ctx context.Context, in *GatewayLocationReqV1, opts ...grpc.CallOption) (*GatewayLocationResV1, error)
	// Get info for the specified gateway
	Info(ctx context.Context, in *GatewayInfoReqV1, opts ...grpc.CallOption) (*GatewayInfoResV1, error)
	// Get a stream of gateway info
	InfoStream(ctx context.Context, in *GatewayInfoStreamReqV1, opts ...grpc.CallOption) (Gateway_InfoStreamClient, error)
}

type gatewayClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayClient(cc grpc.ClientConnInterface) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) RegionParams(ctx context.Context, in *GatewayRegionParamsReqV1, opts ...grpc.CallOption) (*GatewayRegionParamsResV1, error) {
	out := new(GatewayRegionParamsResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.gateway/region_params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Location(ctx context.Context, in *GatewayLocationReqV1, opts ...grpc.CallOption) (*GatewayLocationResV1, error) {
	out := new(GatewayLocationResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.gateway/location", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Info(ctx context.Context, in *GatewayInfoReqV1, opts ...grpc.CallOption) (*GatewayInfoResV1, error) {
	out := new(GatewayInfoResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.gateway/info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) InfoStream(ctx context.Context, in *GatewayInfoStreamReqV1, opts ...grpc.CallOption) (Gateway_InfoStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Gateway_ServiceDesc.Streams[0], "/helium.iot_config.gateway/info_stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &gatewayInfoStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gateway_InfoStreamClient interface {
	Recv() (*GatewayInfoStreamResV1, error)
	grpc.ClientStream
}

type gatewayInfoStreamClient struct {
	grpc.ClientStream
}

func (x *gatewayInfoStreamClient) Recv() (*GatewayInfoStreamResV1, error) {
	m := new(GatewayInfoStreamResV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GatewayServer is the server API for Gateway service.
// All implementations must embed UnimplementedGatewayServer
// for forward compatibility
type GatewayServer interface {
	// Return the region params for the asserted location of the signed gateway
	// address (no auth, but signature validated)
	RegionParams(context.Context, *GatewayRegionParamsReqV1) (*GatewayRegionParamsResV1, error)
	// Get H3 Location for a gateway (auth admin only)
	Location(context.Context, *GatewayLocationReqV1) (*GatewayLocationResV1, error)
	// Get info for the specified gateway
	Info(context.Context, *GatewayInfoReqV1) (*GatewayInfoResV1, error)
	// Get a stream of gateway info
	InfoStream(*GatewayInfoStreamReqV1, Gateway_InfoStreamServer) error
	mustEmbedUnimplementedGatewayServer()
}

// UnimplementedGatewayServer must be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (UnimplementedGatewayServer) RegionParams(context.Context, *GatewayRegionParamsReqV1) (*GatewayRegionParamsResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegionParams not implemented")
}
func (UnimplementedGatewayServer) Location(context.Context, *GatewayLocationReqV1) (*GatewayLocationResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Location not implemented")
}
func (UnimplementedGatewayServer) Info(context.Context, *GatewayInfoReqV1) (*GatewayInfoResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedGatewayServer) InfoStream(*GatewayInfoStreamReqV1, Gateway_InfoStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method InfoStream not implemented")
}
func (UnimplementedGatewayServer) mustEmbedUnimplementedGatewayServer() {}

// UnsafeGatewayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayServer will
// result in compilation errors.
type UnsafeGatewayServer interface {
	mustEmbedUnimplementedGatewayServer()
}

func RegisterGatewayServer(s grpc.ServiceRegistrar, srv GatewayServer) {
	s.RegisterService(&Gateway_ServiceDesc, srv)
}

func _Gateway_RegionParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayRegionParamsReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).RegionParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.gateway/region_params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).RegionParams(ctx, req.(*GatewayRegionParamsReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Location_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayLocationReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Location(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.gateway/location",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Location(ctx, req.(*GatewayLocationReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayInfoReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.gateway/info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Info(ctx, req.(*GatewayInfoReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_InfoStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GatewayInfoStreamReqV1)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayServer).InfoStream(m, &gatewayInfoStreamServer{stream})
}

type Gateway_InfoStreamServer interface {
	Send(*GatewayInfoStreamResV1) error
	grpc.ServerStream
}

type gatewayInfoStreamServer struct {
	grpc.ServerStream
}

func (x *gatewayInfoStreamServer) Send(m *GatewayInfoStreamResV1) error {
	return x.ServerStream.SendMsg(m)
}

// Gateway_ServiceDesc is the grpc.ServiceDesc for Gateway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gateway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "helium.iot_config.gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "region_params",
			Handler:    _Gateway_RegionParams_Handler,
		},
		{
			MethodName: "location",
			Handler:    _Gateway_Location_Handler,
		},
		{
			MethodName: "info",
			Handler:    _Gateway_Info_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "info_stream",
			Handler:       _Gateway_InfoStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service/iot_config.proto",
}

// AdminClient is the client API for Admin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdminClient interface {
	// Authorize a public key for validating trusted rpcs
	AddKey(ctx context.Context, in *AdminAddKeyReqV1, opts ...grpc.CallOption) (*AdminKeyResV1, error)
	// Deauthorize a public key for validating trusted rpcs
	RemoveKey(ctx context.Context, in *AdminRemoveKeyReqV1, opts ...grpc.CallOption) (*AdminKeyResV1, error)
	// Load params and cell indexes for a region into the config service (auth
	// admin only)
	LoadRegion(ctx context.Context, in *AdminLoadRegionReqV1, opts ...grpc.CallOption) (*AdminLoadRegionResV1, error)
	// Return the region params for the specified region
	RegionParams(ctx context.Context, in *RegionParamsReqV1, opts ...grpc.CallOption) (*RegionParamsResV1, error)
}

type adminClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminClient(cc grpc.ClientConnInterface) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) AddKey(ctx context.Context, in *AdminAddKeyReqV1, opts ...grpc.CallOption) (*AdminKeyResV1, error) {
	out := new(AdminKeyResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.admin/add_key", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RemoveKey(ctx context.Context, in *AdminRemoveKeyReqV1, opts ...grpc.CallOption) (*AdminKeyResV1, error) {
	out := new(AdminKeyResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.admin/remove_key", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) LoadRegion(ctx context.Context, in *AdminLoadRegionReqV1, opts ...grpc.CallOption) (*AdminLoadRegionResV1, error) {
	out := new(AdminLoadRegionResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.admin/load_region", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RegionParams(ctx context.Context, in *RegionParamsReqV1, opts ...grpc.CallOption) (*RegionParamsResV1, error) {
	out := new(RegionParamsResV1)
	err := c.cc.Invoke(ctx, "/helium.iot_config.admin/region_params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServer is the server API for Admin service.
// All implementations must embed UnimplementedAdminServer
// for forward compatibility
type AdminServer interface {
	// Authorize a public key for validating trusted rpcs
	AddKey(context.Context, *AdminAddKeyReqV1) (*AdminKeyResV1, error)
	// Deauthorize a public key for validating trusted rpcs
	RemoveKey(context.Context, *AdminRemoveKeyReqV1) (*AdminKeyResV1, error)
	// Load params and cell indexes for a region into the config service (auth
	// admin only)
	LoadRegion(context.Context, *AdminLoadRegionReqV1) (*AdminLoadRegionResV1, error)
	// Return the region params for the specified region
	RegionParams(context.Context, *RegionParamsReqV1) (*RegionParamsResV1, error)
	mustEmbedUnimplementedAdminServer()
}

// UnimplementedAdminServer must be embedded to have forward compatible implementations.
type UnimplementedAdminServer struct {
}

func (UnimplementedAdminServer) AddKey(context.Context, *AdminAddKeyReqV1) (*AdminKeyResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddKey not implemented")
}
func (UnimplementedAdminServer) RemoveKey(context.Context, *AdminRemoveKeyReqV1) (*AdminKeyResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveKey not implemented")
}
func (UnimplementedAdminServer) LoadRegion(context.Context, *AdminLoadRegionReqV1) (*AdminLoadRegionResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadRegion not implemented")
}
func (UnimplementedAdminServer) RegionParams(context.Context, *RegionParamsReqV1) (*RegionParamsResV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegionParams not implemented")
}
func (UnimplementedAdminServer) mustEmbedUnimplementedAdminServer() {}

// UnsafeAdminServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServer will
// result in compilation errors.
type UnsafeAdminServer interface {
	mustEmbedUnimplementedAdminServer()
}

func RegisterAdminServer(s grpc.ServiceRegistrar, srv AdminServer) {
	s.RegisterService(&Admin_ServiceDesc, srv)
}

func _Admin_AddKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminAddKeyReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).AddKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.admin/add_key",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).AddKey(ctx, req.(*AdminAddKeyReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RemoveKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminRemoveKeyReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RemoveKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.admin/remove_key",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RemoveKey(ctx, req.(*AdminRemoveKeyReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_LoadRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminLoadRegionReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).LoadRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.admin/load_region",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).LoadRegion(ctx, req.(*AdminLoadRegionReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RegionParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionParamsReqV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RegionParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helium.iot_config.admin/region_params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RegionParams(ctx, req.(*RegionParamsReqV1))
	}
	return interceptor(ctx, in, info, handler)
}

// Admin_ServiceDesc is the grpc.ServiceDesc for Admin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Admin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "helium.iot_config.admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "add_key",
			Handler:    _Admin_AddKey_Handler,
		},
		{
			MethodName: "remove_key",
			Handler:    _Admin_RemoveKey_Handler,
		},
		{
			MethodName: "load_region",
			Handler:    _Admin_LoadRegion_Handler,
		},
		{
			MethodName: "region_params",
			Handler:    _Admin_RegionParams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/iot_config.proto",
}
